package format

import (
	"fmt"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/extract-scope-go/go-scope/internal/types"
)

// ToMarkdown formats an Extract as markdown
func ToMarkdown(ext types.Extract, opts types.Options) (string, error) {
	var b strings.Builder

	// Header
	b.WriteString(fmt.Sprintf("# Code Extract: %s\n\n", ext.Target.Name))

	// Metadata
	if ext.Target.File != "" {
		b.WriteString(fmt.Sprintf("**File**: %s:%d\n", ext.Target.File, ext.Target.Line))
	}
	if ext.Target.Package != "" {
		b.WriteString(fmt.Sprintf("**Package**: %s\n", ext.Target.Package))
	}
	if ext.Target.Kind != "" {
		b.WriteString(fmt.Sprintf("**Kind**: %s\n", ext.Target.Kind))
	}
	if ext.Target.Receiver != "" {
		b.WriteString(fmt.Sprintf("**Receiver**: %s\n", ext.Target.Receiver))
	}
	b.WriteString(fmt.Sprintf("**Extracted**: %s\n", time.Now().Format("2006-01-02 15:04:05")))

	b.WriteString("\n---\n\n")

	// Metrics (if enabled)
	if opts.IncludeMetrics && ext.Metrics != nil {
		b.WriteString("## Metrics\n\n")
		b.WriteString(fmt.Sprintf("- Lines of Code: %d\n", ext.Metrics.LinesOfCode))
		if ext.Metrics.LogicalLines > 0 {
			b.WriteString(fmt.Sprintf("- Logical Lines: %d\n", ext.Metrics.LogicalLines))
		}
		b.WriteString(fmt.Sprintf("- Cyclomatic Complexity: %d\n", ext.Metrics.CyclomaticComplexity))
		b.WriteString(fmt.Sprintf("- Dependencies: %d\n", ext.Metrics.DependencyCount))
		if len(ext.Metrics.ExternalPackages) > 0 {
			b.WriteString(fmt.Sprintf("- External Packages: %d\n", len(ext.Metrics.ExternalPackages)))
		}
		b.WriteString("\n---\n\n")
	}

	// Target Symbol
	b.WriteString("## Target Symbol\n\n")
	if ext.Target.Doc != "" {
		b.WriteString(fmt.Sprintf("%s\n\n", strings.TrimSpace(ext.Target.Doc)))
	}
	b.WriteString("```go\n")
	if ext.Target.Code != "" {
		b.WriteString(ext.Target.Code)
		if !strings.HasSuffix(ext.Target.Code, "\n") {
			b.WriteString("\n")
		}
	} else {
		b.WriteString(fmt.Sprintf("// No code available for %s\n", ext.Target.Name))
	}
	b.WriteString("```\n\n")

	if ext.Target.File != "" {
		b.WriteString(fmt.Sprintf("*Location: %s:%d-%d*\n\n",
			filepath.Base(ext.Target.File), ext.Target.Line, ext.Target.EndLine))
	}

	// Dependencies (grouped by depth)
	if len(ext.References) > 0 {
		b.WriteString("---\n\n")
		b.WriteString("## Dependencies\n\n")

		// Group by depth
		depthMap := make(map[int][]types.Reference)
		maxDepth := 0
		for _, ref := range ext.References {
			depthMap[ref.Depth] = append(depthMap[ref.Depth], ref)
			if ref.Depth > maxDepth {
				maxDepth = ref.Depth
			}
		}

		// Print by depth
		for depth := 1; depth <= maxDepth; depth++ {
			refs := depthMap[depth]
			if len(refs) == 0 {
				continue
			}

			if maxDepth > 1 {
				b.WriteString(fmt.Sprintf("### Depth %d\n\n", depth))
			}

			// Sort by name for consistent output
			sort.Slice(refs, func(i, j int) bool {
				return refs[i].Symbol.Name < refs[j].Symbol.Name
			})

			for _, ref := range refs {
				b.WriteString(formatReference(ref, opts))
			}
		}
	}

	// External References
	if len(ext.External) > 0 {
		b.WriteString("---\n\n")
		b.WriteString("## External References\n\n")

		// Sort for consistent output
		sorted := make([]string, len(ext.External))
		copy(sorted, ext.External)
		sort.Strings(sorted)

		for _, extRef := range sorted {
			b.WriteString(fmt.Sprintf("- `%s`\n", extRef))
		}
		b.WriteString("\n")
	}

	// Callers (if enabled)
	if opts.ShowCallers && len(ext.Callers) > 0 {
		b.WriteString("---\n\n")
		b.WriteString("## Called By\n\n")

		for _, caller := range ext.Callers {
			b.WriteString(fmt.Sprintf("**%s** - `%s`\n", caller.Function, formatFilePos(caller.File, caller.Line)))
			if caller.Context != "" {
				b.WriteString(fmt.Sprintf("```go\n%s\n```\n", caller.Context))
			}
			b.WriteString("\n")
		}
	}

	// Git History (if enabled)
	if opts.GitBlame && len(ext.GitHistory) > 0 {
		b.WriteString("---\n\n")
		b.WriteString("## Recent Changes\n\n")

		for _, blame := range ext.GitHistory {
			b.WriteString(fmt.Sprintf("- **%s** by %s - \"%s\"\n",
				blame.Date.Format("2006-01-02"), blame.Author, blame.Message))
		}
		b.WriteString("\n")
	}

	// Dependency Graph (if present)
	if ext.Graph != "" {
		b.WriteString("---\n\n")
		b.WriteString("## Dependency Graph\n\n")
		b.WriteString("```\n")
		b.WriteString(ext.Graph)
		b.WriteString("\n```\n\n")
	}

	// Footer
	b.WriteString("---\n\n")
	b.WriteString("*Generated by go-scope*\n")

	return b.String(), nil
}

// formatReference formats a single reference
func formatReference(ref types.Reference, opts types.Options) string {
	var b strings.Builder

	// Symbol name as heading
	b.WriteString(fmt.Sprintf("#### %s\n\n", ref.Symbol.Name))

	// Metadata
	if ref.Symbol.Package != "" && ref.Symbol.File != "" {
		b.WriteString(fmt.Sprintf("**Location**: %s (%s:%d)\n\n",
			ref.Symbol.Package, filepath.Base(ref.Symbol.File), ref.Symbol.Line))
	} else if ref.Symbol.Package != "" {
		b.WriteString(fmt.Sprintf("**Package**: %s\n\n", ref.Symbol.Package))
	}

	if ref.Symbol.Kind != "" {
		b.WriteString(fmt.Sprintf("**Kind**: %s", ref.Symbol.Kind))
		if ref.Symbol.Receiver != "" {
			b.WriteString(fmt.Sprintf(" (%s)", ref.Symbol.Receiver))
		}
		b.WriteString("\n\n")
	}

	// Documentation
	if ref.Symbol.Doc != "" {
		b.WriteString(fmt.Sprintf("%s\n\n", strings.TrimSpace(ref.Symbol.Doc)))
	}

	// Code
	if ref.External && ref.Stub {
		// External stub - just show signature
		if ref.Signature != "" {
			b.WriteString(fmt.Sprintf("```go\n// External: %s\n%s\n```\n\n", ref.Symbol.Package, ref.Signature))
		} else {
			b.WriteString(fmt.Sprintf("*External symbol from `%s`*\n\n", ref.Symbol.Package))
		}
	} else if ref.Symbol.Code != "" {
		// Full code
		b.WriteString("```go\n")
		b.WriteString(ref.Symbol.Code)
		if !strings.HasSuffix(ref.Symbol.Code, "\n") {
			b.WriteString("\n")
		}
		b.WriteString("```\n\n")
	}

	// Reference info
	if opts.Annotate && ref.ReferencedBy != "" {
		b.WriteString(fmt.Sprintf("*Referenced by: %s (reason: %s)*\n\n", ref.ReferencedBy, ref.Reason))
	}

	return b.String()
}

// formatFilePos formats file and line as a readable string
func formatFilePos(file string, line int) string {
	if file == "" {
		return fmt.Sprintf("line %d", line)
	}
	return fmt.Sprintf("%s:%d", filepath.Base(file), line)
}

// Helper to check if a string is in a slice
func contains(slice []string, str string) bool {
	for _, s := range slice {
		if s == str {
			return true
		}
	}
	return false
}
